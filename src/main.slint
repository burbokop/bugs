import { Slider, GroupBox, HorizontalBox, VerticalBox, GridBox } from "std-widgets.slint";

export struct BugBrainInput {
    relative-energy: float,
    rotation: angle,
    proximity-to-food: float,
    direction-to-nearest-food: float,
    age: float,
    proximity-to-bug: float,
    direction-to-nearest-bug: float,
    color-of-nearest-bug: color,
    relative-baby-charge: float,
}

export struct BugBrainOutput {
    velocity: float,
    desired-rotation: float,
    rotation-velocity: float,
    baby-charging-rate: float,
}

export struct BugBrainLog {
    input: BugBrainInput,
    output: BugBrainOutput,
}

export struct BugInfo  {
    id: int,
    genes: [float],
    x: float,
    y: float,
    rotation: angle,
    size: float,
    energy-level: float,
    energy-capacity: float,
    age: percent,
    color: color,
    baby-charge-level: float,
    baby-charge-capacity: float,
    heat-level: float,
    heat-capacity: float,
}

export struct EnvInfo {
    // seconds from start of experiment
    now: duration,
    time-speed: float,
    pause: bool,
    bugs-count: int,
    food-count: int,
}

component Empty {}

global Utils {
    pure public function color-to-string(c: color) -> string {
        return "(" + c.alpha + ", " + c.red + ", " + c.green + ", " + c.blue + ")";
    }
}

export component MainWindow inherits Window {
    in property <image> env-canvas <=> env-canvas.source;
    in property <image> brain-canvas <=> brain-canvas.source;

    in property <float> fps;
    in property <float> tps;
    in property <EnvInfo> env-info;
    in property <BugInfo> selected-bug-info;
    in property <BugBrainLog> selected-bug-last-brain-log;

    out property <int> requested-env-canvas-width: env-canvas.width / 1phx;
    out property <int> requested-env-canvas-height: env-canvas.height / 1phx;

    out property <int> requested-brain-canvas-width: brain-canvas.width / 1phx;
    out property <int> requested-brain-canvas-height: brain-canvas.height / 1phx;

    pure callback pointer-event(int, length, length);
    pure callback scroll-event(length, length, length, length, bool, bool) -> bool;
    pure callback key-press-event(string) -> bool;
    pure callback key-release-event(string) -> bool;

    public function init_focus() {
        focus-scope.focus()
    }

    title: "The Bugs";
    preferred-width: 1000px;
    preferred-height: 600px;

    HorizontalBox {
        padding: 0;

        VerticalLayout {
            width: 500px;

            Text {
                font-size: 20px;
                text: "The Bugs Environment";
                horizontal-alignment: center;
            }

            Text {
                font-size: 20px;
                text: "Environment:";
            }

            Text {
                font-size: 14px;
                text: "time since start: \{(root.env-info.now/1s).round()}s";
            }

            Text {
                font-size: 14px;
                text: "time speed: \{root.env-info.time-speed}";
            }

            Text {
                font-size: 14px;
                text: "pause: \{root.env-info.pause ? "true" : "false"}";
            }

            Text {
                font-size: 14px;
                text: "bugs count: \{root.env-info.bugs-count}";
            }

            Text {
                font-size: 14px;
                text: "food count: \{root.env-info.food-count}";
            }

            Text {
                font-size: 20px;
                text: "Selected bug:";
            }

            Text {
                font-size: 14px;
                text: "id: " + root.selected-bug-info.id;
            }

            Text {
                font-size: 14px;
                text: "position: { \{(root.selected-bug-info.x * 10).round() / 10}, \{(root.selected-bug-info.y * 10).round() / 10} }";
            }

            Text {
                font-size: 14px;
                text: "rotation: " + (root.selected-bug-info.rotation / 1deg).round() + "째";
            }

            Text {
                font-size: 14px;
                text: "size: " + root.selected-bug-info.size;
            }

            Text {
                font-size: 14px;
                text: "energy-level: \{(root.selected-bug-info.energy-level * 100).round() / 100} / \{(root.selected-bug-info.energy-capacity * 100).round() / 100}";
            }

            Text {
                font-size: 14px;
                text: "age: " + (root.selected-bug-info.age / 1% * 10000).round() / 100 + "%";
            }

            Text {
                font-size: 14px;
                color: root.selected-bug-info.color;
                text: "color: \{Utils.color-to-string(root.selected-bug-info.color)}";
            }

            Text {
                font-size: 14px;
                text: "baby-charge: \{(root.selected-bug-info.baby-charge-level * 100).round() / 100} / \{(root.selected-bug-info.baby-charge-capacity * 100).round() / 100}";
            }

            Text {
                font-size: 14px;
                text: "heat: \{(root.selected-bug-info.heat-level * 100).round() / 100} / \{(root.selected-bug-info.heat-capacity * 100).round() / 100}";
            }

            Text {
                font-size: 14px;
                text: "Brain input:";
            }

            Text {
                font-size: 14px;
                text: "         energy_level: \{(root.selected-bug-last-brain-log.input.relative-energy * 100).round() / 100}";
            }

            Text {
                font-size: 14px;
                text: "         rotation: " + (root.selected-bug-last-brain-log.input.rotation / 1deg).round() + "째";
            }

            Text {
                font-size: 14px;
                text: "         proximity_to_food: " + root.selected-bug-last-brain-log.input.proximity_to_food;
            }

            Text {
                font-size: 14px;
                text: "         direction_to_nearest_food: " + root.selected-bug-last-brain-log.input.direction_to_nearest_food;
            }

            Text {
                font-size: 14px;
                text: "         age: " + root.selected-bug-last-brain-log.input.age;
            }

            Text {
                font-size: 14px;
                text: "         proximity_to_bug: " + root.selected-bug-last-brain-log.input.proximity_to_bug;
            }

            Text {
                font-size: 14px;
                text: "         direction_to_nearest_bug: " + root.selected-bug-last-brain-log.input.direction_to_nearest_bug;
            }

            Text {
                font-size: 14px;
                text: "         color_of_nearest_bug: \{Utils.color-to-string(root.selected-bug-last-brain-log.input.color_of_nearest_bug)}";
            }

            Text {
                font-size: 14px;
                text: "         baby_charge: \{(root.selected-bug-last-brain-log.input.relative-baby-charge * 100).round()/100}";
            }

            Text {
                font-size: 14px;
                text: "Brain output:";
            }

            Text {
                font-size: 14px;
                text: "         velocity: \{root.selected-bug-last-brain-log.output.velocity}";
            }

            Text {
                font-size: 14px;
                text: "         desired_rotation: \{root.selected-bug-last-brain-log.output.desired-rotation}째";
            }

            Text {
                font-size: 14px;
                text: "         rotation_velocity: \{root.selected-bug-last-brain-log.output.rotation-velocity}째/s";
            }

            Text {
                font-size: 14px;
                text: "         baby_charging_rate: \{root.selected-bug-last-brain-log.output.baby-charging-rate}";
            }

            genes-area := Rectangle {
                for gene[index] in root.selected-bug-info.genes: Rectangle {
                    x: mod(index, 16) * min(genes-area.width, genes-area.height) / 16;
                    y: (index / 16) * min(genes-area.width, genes-area.height) / 16;

                    width: min(genes-area.width, genes-area.height) / 16;
                    height: min(genes-area.width, genes-area.height) / 16;

                    Text {
                        font-size: 10px;
                        text: (gene * 10).round() / 10;
                    }

                    background: index < 208
                        ? #d81159          // brain
                        : index < 209
                        ? #8f2d56          // max age
                        : index < 210
                        ? #8ffd56          // max size
                        : index < 213
                        ? #218380          // color

                        : #73d2de;         // not used

                    /**
                        0..208   - brain
                        208      - max_age
                        209..212 - color
                        212..256 - not used
                    */
                }
            }
        }

        env-canvas := Image {
            touch := TouchArea {
                pointer-event(event) => {
                    if(event.kind == PointerEventKind.up) {
                        root.pointer-event(0, self.mouse-x, self.mouse-y);
                    } else if(event.kind == PointerEventKind.down) {
                        root.pointer-event(1, self.mouse-x, self.mouse-y);
                    } else if(event.kind == PointerEventKind.move) {
                        root.pointer-event(2, self.mouse-x, self.mouse-y);
                    } else if(event.kind == PointerEventKind.cancel) {
                        root.pointer-event(3, self.mouse-x, self.mouse-y);
                    }
                }

                scroll-event(event) => {
                    root.scroll-event(self.mouse-x, self.mouse-y, event.delta-x, event.delta-y, event.modifiers.shift, event.modifiers.control) ? accept : reject
                }

                moved => {
                    if (self.enabled && self.pressed) {
                        // TODO
                    }
                }

                mouse-cursor: self.pressed ? MouseCursor.grabbing : MouseCursor.grab;
            }

            VerticalBox {
                x: 0;
                y: 0;
                Text {
                    text: "fps: \{(root.fps * 10).round() / 10}";
                }

                Text {
                    text: "tps: \{(root.tps * 10).round() / 10}";
                }

                Empty {}
            }
        }

        brain-canvas := Image {
            width: 320px;
        }
    }

    focus-scope := FocusScope {
        enabled: true;

        key-pressed(event) => {
            return root.key-press-event(event.text) ? accept : reject;
        }

        key-released(event) => {
            return root.key-release-event(event.text) ? accept : reject;
        }
    }
}

